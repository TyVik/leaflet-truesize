{"version":3,"file":"Leaflet.TrueSize.min.js","sources":["../node_modules/@turf/helpers/main.es.js","../node_modules/@turf/bearing/node_modules/@turf/invariant/main.es.js","../node_modules/@turf/bearing/main.es.js","../node_modules/@turf/distance/node_modules/@turf/invariant/main.es.js","../node_modules/@turf/distance/main.es.js","../node_modules/@turf/destination/node_modules/@turf/helpers/index.js","../node_modules/@turf/invariant/node_modules/@turf/helpers/index.mjs","../node_modules/@turf/invariant/index.mjs","../node_modules/@turf/destination/index.js","../node_modules/@turf/meta/index.mjs","../src/index.js"],"sourcesContent":["/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nexport var factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nexport var unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nexport var areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id !== 0 && id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id === 0 || id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nexport function radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nexport function degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nexport function distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nexport function distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nexport function radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nexport function bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nexport function convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","import { feature, point, lineString, isObject } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nexport function findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nexport function findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n","import L from 'leaflet';\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfDestination from '@turf/destination';\nimport { coordAll as turfCoordAll } from '@turf/meta';\n\nlet id = 0;\n\nL.TrueSize = L.Layer.extend({\n  geoJSON: {\n    type: 'Feature',\n    properties: {},\n    geometry: {\n      type: 'Polygon',\n      coordinates: []\n    }\n  },\n\n  options: {\n    color: '#FF0000',\n    stroke: true,\n    weight: 1,\n    opacity: 1,\n    lineCap: 'round',\n    lineJoin: 'round',\n    dashArray: null,\n    dashOffset: null,\n    fill: true,\n    fillColor: '#FF0000',\n    fillOpacity: 0.3,\n    fillRule: 'evenodd',\n    className: null,\n    markerDiv: null,\n    markerClass: null,\n    iconAnchor: []\n  },\n\n  initialize(geoJSON = this.geoJSON, options = {}) {\n    // merge default and passed options\n    this._options = Object.assign({}, this.options, options);\n    this._geometryType = geoJSON.geometry.type;\n\n    L.Util.setOptions(this, this._options);\n    this._initGeoJson(geoJSON, this._options);\n  },\n\n  _initGeoJson(geoJSON, options) {\n    this._geoJSONLayer = L.geoJSON(geoJSON, options);\n    // for unique plugin id\n    this._currentId = id++;\n  },\n\n  setCenter(center) {\n    const layerCenter = this._currentLayer.getBounds().getCenter();\n    this._initialBearingDistance = this._getBearingDistance([\n      layerCenter.lng,\n      layerCenter.lat\n    ]);\n\n    this._redraw(center.slice(0).reverse());\n  },\n\n  onAdd(map) {\n    this._map = map;\n    this._geoJSONLayer.addTo(this._map);\n\n    // our currentlayer is always the first layer of geoJson layersgroup\n    // but has a dynamic key\n    this._currentLayer = this._geoJSONLayer.getLayers()[0];\n    const centerCoords = this._currentLayer.getBounds().getCenter();\n\n    // wrap currentlayer into draggable layer\n    this._createDraggable(this._currentLayer);\n\n    if (this._options.markerDiv && this._options.markerDiv.length) {\n      this._dragMarker = this._createMarker(centerCoords, this._options);\n      this._dragMarker.addTo(this._map);\n    }\n  },\n\n  _createMarker(center, options) {\n    const { markerClass, markerDiv, iconAnchor } = options;\n    const dragIcon = L.divIcon({\n      className: markerClass,\n      html: markerDiv,\n      iconAnchor\n    });\n\n    return L.marker(center, { icon: dragIcon, draggable: true })\n      .on('dragstart', this._onMarkerDragStart, this)\n      .on('drag', this._onMarkerDrag, this);\n  },\n\n  _onMarkerDragStart(evt) {\n    const { lng, lat } = evt.target._latlng;\n\n    this._initialBearingDistance = this._getBearingDistance([lng, lat]);\n  },\n\n  _onMarkerDrag(evt) {\n    this._redraw([evt.latlng.lng, evt.latlng.lat]);\n  },\n\n  _createDraggable(layer) {\n    const draggablePath = new L.Draggable(layer._path);\n    draggablePath.enable();\n\n    draggablePath\n      .on('dragstart', this._onDragStart, this)\n      .on('drag', this._onDrag, this);\n  },\n\n  _onDragStart(evt) {\n    const event = evt.touches ? evt.touches[0] : evt.target;\n    const pos = this._getPositionFromEvent(event);\n    const coords = this._getLatLngFromPosition(pos);\n\n    this._initialBearingDistance = this._getBearingDistance(coords);\n  },\n\n  _onDrag(evt) {\n    const event = evt.touches ? evt.touches[0] : evt.originalEvent;\n    const pos = this._getPositionFromEvent(event);\n    const coords = this._getLatLngFromPosition(pos);\n\n    this._redraw(coords);\n  },\n\n  _getPositionFromEvent(evt) {\n    if (typeof evt._startPoint !== 'undefined') {\n      return evt._startPoint;\n    }\n\n    return { x: evt.clientX, y: evt.clientY };\n  },\n\n  _getLatLngFromPosition(pos) {\n    const { left, top } = this._map._container.getClientRects()[0];\n    const { x, y } = pos;\n\n    const posWithOffset = L.point(x - left, y - top);\n    const { lng, lat } = this._map.containerPointToLatLng(posWithOffset);\n    return [lng, lat];\n  },\n\n  _getBearingDistance(center) {\n    if (this._isMultiPolygon()) {\n      return this._currentLayer.feature.geometry.coordinates.map(coords =>\n        coords[0].map(coord => this._getBearingAndDistance(center, coord))\n      );\n    }\n\n    return turfCoordAll(this._currentLayer.feature).map(coord =>\n      this._getBearingAndDistance(center, coord)\n    );\n  },\n\n  _getBearingAndDistance(center, coord) {\n    const bearing = turfBearing(center, coord);\n    const distance = turfDistance(center, coord, { units: 'kilometers' });\n    return { bearing, distance };\n  },\n\n  _redraw(newPos) {\n    let newPoints;\n\n    if (this._isMultiPolygon()) {\n      newPoints = this._initialBearingDistance.map(coords => [\n        coords.map(params => {\n          return turfDestination(newPos, params.distance, params.bearing, {\n            units: 'kilometers'\n          }).geometry.coordinates;\n        })\n      ]);\n    } else {\n      newPoints = this._initialBearingDistance.map(params => {\n        return turfDestination(newPos, params.distance, params.bearing, {\n          units: 'kilometers'\n        }).geometry.coordinates;\n      });\n    }\n\n    const newFeature = {\n      type: 'Feature',\n      properties: {},\n      geometry: {\n        type: this._geometryType,\n        coordinates: this._getCoordsByType(newPoints, this._geometryType)\n      }\n    };\n\n    this._geoJSONLayer.clearLayers();\n    this._geoJSONLayer.addData(newFeature);\n    // our currentlayer is always the first layer of geoJson layersgroup\n    // but has a dynamic key\n    this._currentLayer = this._geoJSONLayer.getLayers()[0];\n    // add draggable hook again, as we using internal a new layer\n    // center marker if existing\n    this._createDraggable(this._currentLayer);\n    this._dragMarker &&\n      this._dragMarker.setLatLng(this._currentLayer.getCenter());\n  },\n\n  onRemove(map) {\n    this._map = map;\n    this._map.removeLayer(this._geoJSONLayer);\n    if (this._dragMarker) {\n      this._map.removeLayer(this._dragMarker);\n    }\n\n    return this;\n  },\n\n  _getCoordsByType(point, type) {\n    switch (type) {\n      case 'LineString': {\n        return point;\n      }\n      case 'Polygon': {\n        return [point];\n      }\n      case 'MultiPolygon': {\n        return point;\n      }\n      default: {\n        return [point];\n      }\n    }\n  },\n\n  _isMultiPolygon() {\n    return this._geometryType === 'MultiPolygon';\n  }\n});\n\nL.trueSize = (geoJSON, options) => new L.TrueSize(geoJSON, options);\n"],"names":["earthRadius","factors","radiansToLength","radians","units","factor","radiansToDegrees","degrees","degreesToRadians","isObject","input","getCoord","coord","bearing","start","end","options","final","calculateFinalBearing","coordinates1","coordinates2","lon1","lon2","lat1","lat2","a","b","bear","distance","from","to","dLat","dLon","exports","feature","geom","properties","feat","geometry","type","coordinates","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","points","featureCollection","coords","_i","coordinates_1","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","multiplier","lengthToRadians","lengthToDegrees","bearingToAzimuth","angle","convertLength","length","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isNumber","validateBBox","bbox","validateId","id","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","getCoords","containsNumber","geojsonType","value","name","featureOf","collectionOf","i","getGeom","geojson","getGeomType","getType","destination","origin","invariant_1","longitude1","helpers_1","latitude1","bearingRad","latitude2","longitude2","lng","lat","coordEach","callback","excludeWrapCoord","k","l","stopG","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordAll","L","TrueSize","Layer","extend","geoJSON","_options","Object","assign","_geometryType","Util","setOptions","_initGeoJson","_geoJSONLayer","_currentId","center","layerCenter","_currentLayer","getBounds","getCenter","_initialBearingDistance","_getBearingDistance","_redraw","slice","reverse","map","_map","addTo","getLayers","centerCoords","_createDraggable","markerDiv","_dragMarker","_createMarker","markerClass","iconAnchor","dragIcon","divIcon","marker","icon","draggable","on","_onMarkerDragStart","_onMarkerDrag","evt","target","_latlng","latlng","layer","draggablePath","Draggable","_path","enable","_onDragStart","_onDrag","event","touches","pos","_getPositionFromEvent","_getLatLngFromPosition","originalEvent","_startPoint","x","clientX","y","clientY","_container","getClientRects","left","top","posWithOffset","containerPointToLatLng","_isMultiPolygon","_this","_getBearingAndDistance","turfCoordAll","turfBearing","turfDistance","newPos","newPoints","turfDestination","params","newFeature","_getCoordsByType","clearLayers","addData","setLatLng","removeLayer","trueSize"],"mappings":"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"}